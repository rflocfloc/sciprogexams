{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Welcome to MkDocs For full documentation visit mkdocs.org . Commands mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit. Project layout mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Home"},{"location":"#welcome-to-mkdocs","text":"For full documentation visit mkdocs.org .","title":"Welcome to MkDocs"},{"location":"#commands","text":"mkdocs new [dir-name] - Create a new project. mkdocs serve - Start the live-reloading docs server. mkdocs build - Build the documentation site. mkdocs -h - Print help message and exit.","title":"Commands"},{"location":"#project-layout","text":"mkdocs.yml # The configuration file. docs/ index.md # The documentation homepage. ... # Other markdown pages, images and other files.","title":"Project layout"},{"location":"template/","text":"Exam/Midterm YYYY_MM_DD Exercises Exercise 1 [FIRST MODULE/SECOND MODULE] some text here, if you need images follow path of respective exam directory Exercise 2 [FIRST MODULE/SECOND MODULE] another text Exercise 3 [FIRST MODULE/SECOND MODULE, lab/theory] another text Exercise 4 [FIRST MODULE/SECOND MODULE, lab/theory] another text Solutions Exercise 1 if you need to add chunk of code for i in range(10): print(f'Hello number {i}!') Exercise 2 another text Exercise 3 another text Exercise 4 another text","title":"Exam/Midterm YYYY_MM_DD"},{"location":"template/#exammidterm-yyyy_mm_dd","text":"","title":"Exam/Midterm YYYY_MM_DD"},{"location":"template/#exercises","text":"","title":"Exercises"},{"location":"template/#exercise-1-first-modulesecond-module","text":"some text here, if you need images follow path of respective exam directory","title":"Exercise 1 [FIRST MODULE/SECOND MODULE]"},{"location":"template/#exercise-2-first-modulesecond-module","text":"another text","title":"Exercise 2 [FIRST MODULE/SECOND MODULE]"},{"location":"template/#exercise-3-first-modulesecond-module-labtheory","text":"another text","title":"Exercise 3 [FIRST MODULE/SECOND MODULE, lab/theory]"},{"location":"template/#exercise-4-first-modulesecond-module-labtheory","text":"another text","title":"Exercise 4 [FIRST MODULE/SECOND MODULE, lab/theory]"},{"location":"template/#solutions","text":"","title":"Solutions"},{"location":"template/#exercise-1","text":"if you need to add chunk of code for i in range(10): print(f'Hello number {i}!')","title":"Exercise 1"},{"location":"template/#exercise-2","text":"another text","title":"Exercise 2"},{"location":"template/#exercise-3","text":"another text","title":"Exercise 3"},{"location":"template/#exercise-4","text":"another text","title":"Exercise 4"},{"location":"2023_12_19/qcb/2023_12_19/","text":"Midterm 2023_12_19 Exercises Exercise 1 [SECOND MODULE, theory] Describe the differences between the Depth-First and the Breadth-First Search algorithms for visiting graphs. Then, apply the DFS to the graph below. Exercise 2 [SECOND MODULE, theory] Given a sorted list L of n elements, please compute the asymptotic computational complexity of the following fun function, explaining your reasoning. def fun(L): if len(L)== 1: return L[0] return max(L[0],fun(L[1:])) Remember that the slicing operator creates a new list to store the sliced elements. Exercise 3 [FIRST MODULE/SECOND MODULE, lab/theory] Implement the sort() method of the class PancakeSort in the file exercise3.py . To test the implementation, execute the file exercise3.py , which is already equipped with a main code that tests the method by sorting the list [7, 5, 10, -11, 3, -4, 99, 1]. Imagine you have a stack of pancakes of different sizes, and you want to arrange them in order from the largest at the bottom to the smallest at the top. Here's how Pancake Sort works: Start with your stack of unsorted pancakes. The stack represents the list of numbers that you want to sort (it is not an actual stack data structure). Iterate over the stack of pancakes (list of numbers) starting from the bottom pancake (end of the list) and going towards the top (first pancake). This because at the end of each iteration the biggest pancake (number) will be moved to the bottom of the stack (last position in the list), and we want to reduce the size of the list we work with at each iteration. At each iteration, identify the biggest pancake ( number ) and get its position X. If the biggest pancake is not already at the top, flip the unsorted stack to move it there (in the first position of the list). This means that you must flip the sub-list that goes from 0 to position X. Now, flip the entire stack (list) so that the biggest pancake is now at the bottom (end of the list). Repeat the process, focusing on a smaller stack each time (excluding the pancake you've already sorted, which is now at the end). Continue until all pancakes are in order (i.e. when you reach the first position in the list) Keep in mind that with flip we mean to reverse the order of the elements in the list (or sub-list). Below there is an example of how the sorting works: Exercise 4 [FIRST MODULE/SECOND MODULE, lab/theory] another text Solutions Exercise 1 if you need to add chunk of code for i in range(10): print(f'Hello number {i}!') Exercise 2 another text Exercise 3 another text Exercise 4 another text","title":"Midterm 2023_12_19"},{"location":"2023_12_19/qcb/2023_12_19/#midterm-2023_12_19","text":"","title":"Midterm 2023_12_19"},{"location":"2023_12_19/qcb/2023_12_19/#exercises","text":"","title":"Exercises"},{"location":"2023_12_19/qcb/2023_12_19/#exercise-1-second-module-theory","text":"Describe the differences between the Depth-First and the Breadth-First Search algorithms for visiting graphs. Then, apply the DFS to the graph below.","title":"Exercise 1 [SECOND MODULE, theory]"},{"location":"2023_12_19/qcb/2023_12_19/#exercise-2-second-module-theory","text":"Given a sorted list L of n elements, please compute the asymptotic computational complexity of the following fun function, explaining your reasoning. def fun(L): if len(L)== 1: return L[0] return max(L[0],fun(L[1:])) Remember that the slicing operator creates a new list to store the sliced elements.","title":"Exercise 2 [SECOND MODULE, theory]"},{"location":"2023_12_19/qcb/2023_12_19/#exercise-3-first-modulesecond-module-labtheory","text":"Implement the sort() method of the class PancakeSort in the file exercise3.py . To test the implementation, execute the file exercise3.py , which is already equipped with a main code that tests the method by sorting the list [7, 5, 10, -11, 3, -4, 99, 1]. Imagine you have a stack of pancakes of different sizes, and you want to arrange them in order from the largest at the bottom to the smallest at the top. Here's how Pancake Sort works: Start with your stack of unsorted pancakes. The stack represents the list of numbers that you want to sort (it is not an actual stack data structure). Iterate over the stack of pancakes (list of numbers) starting from the bottom pancake (end of the list) and going towards the top (first pancake). This because at the end of each iteration the biggest pancake (number) will be moved to the bottom of the stack (last position in the list), and we want to reduce the size of the list we work with at each iteration. At each iteration, identify the biggest pancake ( number ) and get its position X. If the biggest pancake is not already at the top, flip the unsorted stack to move it there (in the first position of the list). This means that you must flip the sub-list that goes from 0 to position X. Now, flip the entire stack (list) so that the biggest pancake is now at the bottom (end of the list). Repeat the process, focusing on a smaller stack each time (excluding the pancake you've already sorted, which is now at the end). Continue until all pancakes are in order (i.e. when you reach the first position in the list) Keep in mind that with flip we mean to reverse the order of the elements in the list (or sub-list). Below there is an example of how the sorting works:","title":"Exercise 3 [FIRST MODULE/SECOND MODULE, lab/theory]"},{"location":"2023_12_19/qcb/2023_12_19/#exercise-4-first-modulesecond-module-labtheory","text":"another text","title":"Exercise 4 [FIRST MODULE/SECOND MODULE, lab/theory]"},{"location":"2023_12_19/qcb/2023_12_19/#solutions","text":"","title":"Solutions"},{"location":"2023_12_19/qcb/2023_12_19/#exercise-1","text":"if you need to add chunk of code for i in range(10): print(f'Hello number {i}!')","title":"Exercise 1"},{"location":"2023_12_19/qcb/2023_12_19/#exercise-2","text":"another text","title":"Exercise 2"},{"location":"2023_12_19/qcb/2023_12_19/#exercise-3","text":"another text","title":"Exercise 3"},{"location":"2023_12_19/qcb/2023_12_19/#exercise-4","text":"another text","title":"Exercise 4"}]}